# Scroll Restoration - Документация

## Обзор

Реализована система восстановления позиции скролла для всех основных экранов приложения. Решение оптимизировано для производительности и работает с ленивой загрузкой контента.

## Архитектура

### 1. `useScrollRestoration` - Основной хук для восстановления скролла

**Особенности:**
- ✅ Автоматическое сохранение позиции при скролле (с дебаунсом 150мс)
- ✅ Восстановление позиции при возврате на страницу
- ✅ Поддержка динамической загрузки контента через зависимости
- ✅ Хранение в `sessionStorage` с временем жизни 30 минут
- ✅ Защита от гонки условий при быстрой навигации
- ✅ Автоматическая очистка устаревших данных
- ✅ **Флаг `isRestoring` для предотвращения мерцания**
- ✅ **Синхронное восстановление без задержек**

**Использование:**
```jsx
const { scrollRef, isRestoring } = useScrollRestoration('unique-key', [dataLength]);

return (
    <div 
        ref={scrollRef} 
        className="overflow-y-scroll"
        style={{ 
            opacity: isRestoring ? 0 : 1,
            transition: isRestoring ? 'none' : 'opacity 0.15s ease-in'
        }}
    >
        {/* Контент */}
    </div>
);
```

**Параметры:**
- `storageKey` - уникальный ключ для хранения позиции
- `dependencies` - массив зависимостей (например, длина списка данных)

### 2. `useLazyLoad` - Расширенная ленивая загрузка

**Улучшения:**
- ✅ Сохранение состояния загрузки в `sessionStorage`
- ✅ Восстановление количества загруженных элементов
- ✅ Синхронизация с восстановлением скролла
- ✅ Автоматическая валидация данных (30 минут)

**Использование:**
```jsx
const { displayedItems, hasMore, loadMoreRef } = useLazyLoad(
    items,           // массив всех элементов
    6,               // начальное количество
    6,               // количество для подгрузки
    'storage-key'    // ключ для сохранения состояния (опционально)
);
```

## Реализация по экранам

### CatalogScreen
- **Ключ скролла:** `catalog-scroll`
- **Ключ ленивой загрузки:** `catalog-lazy-load`
- **Зависимости:** `[items.length]`
- Самая сложная реализация с ленивой загрузкой и большим списком товаров

## Технические детали

### Алгоритм работы

1. **При монтировании компонента:**
   - Проверяется `sessionStorage` на наличие сохраненной позиции
   - Валидируются данные (время жизни, pathname)
   - Устанавливается флаг `isRestoring` (скрывает контент через opacity: 0)
   - Восстанавливается позиция **синхронно** без задержек
   - Контент плавно появляется после восстановления

2. **При скролле:**
   - Позиция сохраняется с дебаунсом 150мс
   - Обновляется timestamp для валидации

3. **При загрузке данных:**
   - Позиция восстанавливается после рендеринга через `requestAnimationFrame`
   - Гарантируется правильный размер контента

4. **При размонтировании:**
   - Позиция сохраняется финально
   - Ресурсы очищаются

### Оптимизации

1. **Дебаунс:** Скролл сохраняется не чаще 1 раза в 150мс
2. **RAF:** Восстановление через `requestAnimationFrame` для плавности
3. **Passive listeners:** Используются passive event listeners для производительности
4. **Автоочистка:** Данные старше 30 минут удаляются автоматически
5. **Защита от гонок:** Флаг `isRestoringRef` предотвращает ложные сохранения
6. **Нет мерцания:** Контент скрыт (opacity: 0) во время восстановления
7. **Синхронное восстановление:** Минимальная задержка перед показом контента

### Хранение данных

```javascript
// Формат данных в sessionStorage
{
    scrollTop: number,      // Позиция скролла в пикселях
    pathname: string,       // Путь страницы для валидации
    timestamp: number       // Unix timestamp для проверки актуальности
}
```

## Преимущества решения

1. **Производительность:** Минимальное влияние на производительность благодаря оптимизациям
2. **UX:** Пользователь возвращается точно туда, где остановился
3. **Надежность:** Защита от edge cases и автоматическая очистка
4. **Масштабируемость:** Легко добавить на новые экраны
5. **Совместимость:** Работает с ленивой загрузкой и динамическим контентом

## Добавление на новый экран

```jsx
import { useScrollRestoration } from '../hooks/useScrollRestoration';

const MyScreen = ({ data }) => {
    // Добавляем хук
    const { scrollRef, isRestoring } = useScrollRestoration('my-screen-scroll', [data.length]);

    return (
        <div 
            ref={scrollRef} 
            className="overflow-y-scroll"
            style={{ 
                opacity: isRestoring ? 0 : 1,
                transition: isRestoring ? 'none' : 'opacity 0.15s ease-in'
            }}
        >
            {/* Ваш контент */}
        </div>
    );
};
```

## Тестирование

Проверьте следующие сценарии:
- ✅ Прокрутка списка → переход на другую страницу → возврат назад
- ✅ Ленивая загрузка → переход → возврат (должны загрузиться те же элементы)
- ✅ Быстрое переключение между экранами
- ✅ Обновление данных (должна сохраниться позиция относительно нового контента)
- ✅ Закрытие приложения > 30 минут → открытие (позиция должна сброситься)

## Troubleshooting

**Проблема:** Скролл не восстанавливается
- Проверьте, что `ref={scrollRef}` установлен на контейнер с `overflow-y-scroll`
- Убедитесь, что данные загружены в момент восстановления

**Проблема:** Видно мерцание/прыжок при восстановлении
- Убедитесь, что используете флаг `isRestoring` с `opacity: 0`
- Проверьте, что стиль применяется к правильному контейнеру
- Можно увеличить время скрытия, изменив timeout в хуке (по умолчанию 50мс)

**Проблема:** Ленивая загрузка не работает с восстановлением
- Убедитесь, что передан `storageKey` в `useLazyLoad`
- Проверьте согласованность ключей хранения

